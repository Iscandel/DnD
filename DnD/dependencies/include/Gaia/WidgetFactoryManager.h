#ifndef H__WIDGETFACTORYMANAGER_100920111703__H
#define H__WIDGETFACTORYMANAGER_100920111703__H

///////////////////////////////////////////////////////////////////////////////
// Headers
///////////////////////////////////////////////////////////////////////////////
#include "Gaia/WidgetFactory.h"
#include "Gaia/tools/Singleton.h"

#include <map>

namespace gaia
{
///////////////////////////////////////////////////////////////////////////////
/// \brief Manager for widget factories.
///////////////////////////////////////////////////////////////////////////////
class GAIA_DLL WidgetFactoryManager : public gaia::Singleton<WidgetFactoryManager>
{
public:
	typedef std::map<std::string, PtrWidgetFactory> FactoryMap;

public:
	///////////////////////////////////////////////////////////////////////////
	/// \brief Registers a new factory in the manager.
	///
	/// \param factory : Smart pointer to the factory to register.
	///////////////////////////////////////////////////////////////////////////
	void addFactory(PtrWidgetFactory factory);

	///////////////////////////////////////////////////////////////////////////
	/// \brief Removes a previously added factory.
	///
	/// \param type : Factory name.
	///////////////////////////////////////////////////////////////////////////
	void removeFactory(const std::string& type);

	///////////////////////////////////////////////////////////////////////////
	/// \brief Returns the factory identified by its type name. If the 
	/// requested factory cannot be found, a GuiException exception is thrown.
	///
	/// \param type : Factory type name.
	///
	/// \return A smart pointer to the factory.
	///////////////////////////////////////////////////////////////////////////
	PtrWidgetFactory getFactory(const std::string& type);

protected:
	std::map<std::string, PtrWidgetFactory> myFactories;
};

};

#endif